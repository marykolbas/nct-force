<html>
  <head>
    <title>INFO 4310 - HW 4</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap">

    <style>
      /* -- general styling -- */
      body, html, main {
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
        font-family: 'Lato', sans-serif;
      }

      main {
        display: flex;
      }

      #graph-container {
        width: 80vw;
      }
      
      #graph {
        width: 100%;
        height: 100%;
      }

      #detail-sidebar {
        width: 20%;
        height: 100vh;
        position: absolute;
        z-index: 0;
        right: 0;
        background-color: white;
        border-left: solid 1px lightgray;
      }

      /* -- styling force diagram elements -- */
      .hovered-arc {
        /* stroke: black; */
        z-index: 4;
      }

      .not-hovered-arc {
        stroke: rgb(231, 231, 231);
        z-index: 0;
      }

      .unconnected-node :not(.filler) {
        opacity: 0.4;
      }

      .node-label:hover, .node:hover{
        cursor: pointer;
      }

      /* styling for sidebar */
      .group_bubble{
        border-style: solid;
        border-radius: 5px;
        margin:5px;
        padding: 5px;
        display: inline-block;
      }
      #detail-sidebar-div{
        margin-left: 20px;
      }
      #name{
        font-size: 20px;
        font-weight: bold;
      }
      
    </style>
   </head>

   <body>
    <main>
        <div id="graph-container">
            <svg id="graph" width="100vw" height ="100vh">
            </svg>
        </div>

        <aside id="detail-sidebar">
            <div id="detail-sidebar-div">
              <p id="name"></p>
              <div id="groups"></div>
              <p id="position"></p>
            </div>
            <svg id="barchart" width="260" height ="300"></svg>
        </aside>
    </main>
  </body>
  
  <script>

    const requestData = async () =>  {
      const songs = await d3.csv("NCT_csv_order1.csv", d3.autoType);

      //convert 'Date' string into datetime 
      var parseTime = d3.timeParse("%m/%d/%Y");
      songs.forEach(d => {
          d.datetime = parseTime(d.Date)
      })
      
      //in chronological order
      let songs_sorted = d3.sort(songs, (d) => d.datetime)

      const member_details = await d3.csv("members_unique_subunits.csv");
      
      

      // --------------------------------------------------------------

      const layer = d3.select("#graph").append("g").attr("id", "draw-layer");
      const width = window.innerWidth * 0.8
      const height = window.innerHeight

      const members = await d3.json("fixed.json");
      var nodes = members.nodes;
      let links = members.edges;

      let viewport = layer.append("g");

      const colorScale = {"NCT 127": "#e76f51", "NCT DREAM": "#e9c46a", "WayV": "#2a9d8f", "SuperM": "#F4A261"}
      const color = d3.scaleOrdinal().domain(["NCT 127", "NCT DREAM", "WayV", "SuperM", "No Subunit"]).range(["#e76f51", "#e9c46a", "#2a9d8f", "#F4A261", "#264653"]);
      
      var plotZoom = d3.zoom().on("zoom", plotZoomed);
      d3.select("#graph").call(plotZoom);

      console.log(nodes, links)

      // bar chart ------------------------------------------------------------------
      const barchart = d3.select("svg#barchart");
      const barchartWidth = barchart.attr("width");
      const barchartHeight = barchart.attr("height");
      const margin = {top: 10, right: 10, bottom: 70, left: 50};
      const chartWidth = barchartWidth - margin.left - margin.right;
      const chartHeight = barchartHeight - margin.top - margin.bottom;

      function makeBarChart(connections){
        let annotations = barchart.append("g").attr("id","annotations");
        let chartArea = barchart.append("g").attr("id","area")
                      .attr("transform",`translate(${margin.left},${margin.top})`);

        connections = d3.sort(connections, (d) => d[1]).reverse()        
        const songExtent = d3.extent(connections, d=>d[1]);
        console.log(songExtent)
        const songScale = d3.scaleLinear().domain([0, songExtent[1]]).range([chartHeight, 0]).nice();

        const leftAxisTicks = songScale.ticks()
                                  .filter(tick => Number.isInteger(tick));

        let leftAxis = d3.axisLeft(songScale).tickFormat(d3.format('d')).tickValues(leftAxisTicks);
        let leftGridlines = d3.axisLeft(songScale)
                              .tickSize(-chartWidth-10)
                              .tickFormat("").tickValues(leftAxisTicks)
        annotations.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(leftAxis)
        annotations.append("g")
                  .attr("class", "y gridlines")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(leftGridlines);
    
        const membersXAxis = d3.map(connections, d => d[0]) 
        const membersXAxisScale = d3.scaleBand().domain(membersXAxis).range([0, chartWidth])
                                         .padding(0.05);

        let bottomAxis = d3.axisBottom(membersXAxisScale)
        annotations.append("g")
                  .attr("class", "x axis")
                  .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                  .call(bottomAxis)
                  .selectAll('text')
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em").attr("transform", "rotate(-65)")
        
        chartArea.selectAll('rect.bar').data(connections)
                  .join('rect').attr('class','bar')
                  .attr("fill", "steelblue")
                  .attr("x", d => membersXAxisScale(d[0]))
                  .attr("y", d => songScale(d[1]))
                  .attr("height", d => songScale(0) - songScale(d[1]))
                  .attr("width", membersXAxisScale.bandwidth());

      }


      // create list of # of songs each node shares with others as "connections"
      nodes.forEach(n=>{ 
        node_collab = []  
        links.forEach(l=>{
          if(n.name===l.source){
            node_collab.push([l.target, l.weight])
          }
          if(n.name===l.target){
            node_collab.push([l.source, l.weight])
          }
        })
        n.connections=node_collab
      })
      console.log("new", nodes)

      var sim = d3.forceSimulation()
                .nodes(nodes)
                .force("links", d3.forceLink()   // Keep nodes that are connected near each other
                                        .links(links)           // give the force an array of source/target objects
                                        .id( d => d['name'] )
                                        // .strength(d=> d.weight)
                                        // .strength (function (d) {return (d.weight)})
                                        .strength(d => d.weight*0.01)
                                        // .distance(d=>console.log(d))
                                        )

                // .force("link", d3.forceLink(links))

                                                // if source and target don't provide array indices for nodes, .id will tell the force what to look for in the nodes when it is trying to connect things together. Provide a getter function for _node elements_
                .force("repulse", d3.forceManyBody().strength(-5000) ) // electrostatic repulsion between all nodes to space them out
                .force("center", d3.forceCenter(width/2.0, height/2.0)) // centering force to make sure points don't fly away completely
                //.on("tick", render)
                ;

        while (sim.alpha() > 0.01) { 
          sim.tick(); 
        }

      function render() {
        // data join for edges
        let lines = viewport.selectAll("path.link").data(links)
            .join(
              enter => enter.append("path")
                            .attr("class","link")
                            .attr("stroke","rgb(231, 231, 231)") 
                            .attr("stroke-width", 2)
                            .style('opacity', 0.6)
                            .attr("fill", "none")
            )
            // .attr("x1", d => d.source.x).attr("x2", d => d.target.x)   // Using the pointers d3.forceLink provides to access node x and y coords
            // .attr("y1", d => d.source.y).attr("y2", d => d.target.y);
            .attr("d", function(d) { // taken from https://stackoverflow.com/questions/13455510/curved-line-on-d3-force-directed-tree
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
            });


        //  data join for nodes
        let circles = viewport.selectAll(".node").data(nodes)
              .join(
                  enter => {
                    const nodeGroup = enter.append("g")
                      .attr("class", "node");

                      nodeGroup.each(function(d) {
                          createNodeDonut(d3.select(this), d.groups);
                      });
                  })
                
        // handle mouseover of nodes

        let nodeGroups = d3.selectAll(".node"); 
        nodeGroups.on("mouseover", function(event, d) { 
          
          if (!d3.select("#detail-sidebar").classed("clicked")) {
            resetNetwork();
            highlightNetwork(d);
            hoverUpdate(d.name);
        }});

        // handle mouseout of nodes
        nodeGroups.on("mouseout", function(event, d) {
            if (!d3.select("#detail-sidebar").classed("clicked")) {
              clearSidebar();
              resetNetwork();
            }
          });

        nodeGroups.on("click", function(event, d) {
          resetNetwork();
          highlightNetwork(d);
          clickUpdate(d.name);
        });

        function highlightNetwork(d) {
          let connectedNames = []; // tracking names of nodes connected to the hovered node

            // iterating over edges to find the ones that are connected to the hovered node
            d3.selectAll("path.link").each(function(l) {
              if (d === l.source || d === l.target) {
                d3.select(this).classed('hovered-arc', true).raise().attr("stroke", d === l.source ? color(l.target.groups[0]) : color(l.source.groups[0]));
                nodeGroups.raise();
                connectedNames.push(l.source.name);
                connectedNames.push(l.target.name);
              } else {
                d3.select(this).classed('hovered-arc', false).lower();
              }
            })

            // make sure connected nodes are on top
            nodeGroups.filter(function() {
                  return connectedNames.includes(d3.select(this).attr("name")); 
            }).raise()

            // reduce opacity of unconnected nodes and lower under highlighted edges
            nodeGroups.filter(function() {
              return !connectedNames.includes(d3.select(this).attr("name")); 
            }).classed('unconnected-node', true).lower()
            d3.selectAll(".link:not(.hovered-arc)").lower()
        }

        function resetNetwork() {
          nodeGroups.classed('unconnected-node', false)
          d3.selectAll("path.link").classed('hovered-arc', false).lower().attr("stroke", "rgb(231, 231, 231)")
        
        }
      
      }
      render();

      function plotZoomed(event) {  
        viewport.attr("transform", event.transform);
      }

      function createNodeDonut(container, groups) {
        const donutWidth = 120;
        const donutHeight = 120;
        const radius = donutWidth / 2;

        const arc = d3.arc()
            .innerRadius(radius * 0.8) 
            .outerRadius(radius); 

        const pie = d3.pie().value(() => 1);

        const arcs = pie(groups);

        const arcPaths = container.selectAll("arc")
            .data(arcs)
            .enter()
            .append("g")
            .attr("class", "arc");

        arcPaths.append("path")
            .attr("d", arc)
            .attr("fill", (d, i) => color(d.data));

        container.append("circle")
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("r", radius * 0.8)
            .attr("fill", "white")
            .attr("class", "filler");

        container.append("text")
            .attr("class", "node-label")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .text(d => d.name);
            
        container.attr("x", -50)
                  .attr("y", -50)
                  .attr("name", d => d.name)
                  .attr("transform", d => `translate(${d.x},${d.y})`)
        
        return container;
      }

      function clickUpdate(name) {
        d3.select("#detail-sidebar").classed("clicked", true)

        let selectedNode = nodes.filter(d => {
          if (d.name === name) {
            return d;
          }
        });

        d3.selectAll('#barchart g').remove()

        makeBarChart(selectedNode[0].connections)
             
        console.log(selectedNode[0].groups)
        d3.select("#name").text(selectedNode[0].name);

        //clear initial bubbles 
        d3.selectAll('#groups g').remove()
        //add new bubbles
        selectedNode[0].groups.forEach(d=>{
          d3.select("#groups").append('g')
                              .attr('class', 'group_bubble')
                              .text(d)
                              .style('background-color', color(d))
        })
        // d3.select("#groups").text(selectedNode[0].groups);

        d3.select("#position").text(`Position: ${member_details[selectedNode[0].index].position}`)
      }

      function hoverUpdate(name) {
        let selectedNode = nodes.filter(d => {
          if (d.name === name) {
            return d;
          }
        });
        
        d3.select("#name").text(selectedNode[0].name);
        // d3.select("#groups").text(selectedNode[0].groups);
      }

      function clearSidebar() {
        if (!d3.select("#detail-sidebar").classed("clicked")) {
          d3.select("#name").text("");
          d3.select("#groups").text("");
        }
        
      }
    }

    
    requestData()

  </script>



</html>
