<html>
  <head>
    <title>INFO 4310 - HW 2</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      /* -- general styling -- */
      body, html, main {
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
      }

      main {
        display: flex;
      }

      #graph-container {
        width: 80vw;
      }
      
      #graph {
        width: 100%;
        height: 100%;
      }

      #detail-sidebar {
        width: 20%;
        height: 100vh;
        position: absolute;
        z-index: 0;
        right: 0;
        background-color: white;
        border-left: solid 1px lightgray;
      }

      /* -- styling force diagram elements -- */
      .hovered-arc {
        stroke: black;
        z-index: 4;
      }

      .not-hovered-arc {
        stroke: lightgray;
        z-index: 0;
      }

      .unconnected-node {
        opacity: 0.4;
      }
      
    </style>
   </head>

   <body>
    <main>
        <div id="graph-container">
            <svg id="graph" width="100vw" height ="100vh">
            </svg>
        </div>

        <aside id="detail-sidebar">
            <p id="small-label">filler text</p>
        </aside>
    </main>
  </body>
  
  <script>

    const requestData = async () =>  {
      // const songs = await d3.csv("NCT_csv_order1.csv", d3.autoType);

      // //convert 'Date' string into datetime 
      // var parseTime = d3.timeParse("%m/%d/%Y");
      // songs.forEach(d => {
      //     d.datetime = parseTime(d.Date)
      // })
      
      // //in chronological order
      // let songs_sorted = d3.sort(songs, (d) => d.datetime)

      // --------------------------------------------------------------

      const layer = d3.select("#graph").append("g").attr("id", "draw-layer");
      const width = window.innerWidth * 0.8
      const height = window.innerHeight

      const members = await d3.json("fixed.json");
      var nodes = members.nodes;
      let links = members.edges;

      let viewport = layer.append("g");
      
      var plotZoom = d3.zoom().on("zoom", plotZoomed);
      d3.select("#graph").call(plotZoom);

      console.log(nodes, links)

      var sim = d3.forceSimulation()
                .nodes(nodes)
                .force("links", d3.forceLink()   // Keep nodes that are connected near each other
                                        .links(links)           // give the force an array of source/target objects
                                        .id( d => d['name'] )
                                        // .strength(d=> d.weight)
                                        // .strength (function (d) {return (d.weight)})
                                        .strength(d => d.weight*0.01)
                                        // .distance(d=>console.log(d))
                                        )

                // .force("link", d3.forceLink(links))

                                                // if source and target don't provide array indices for nodes, .id will tell the force what to look for in the nodes when it is trying to connect things together. Provide a getter function for _node elements_
                .force("repulse", d3.forceManyBody().strength(-2000) ) // electrostatic repulsion between all nodes to space them out
                .force("center", d3.forceCenter(width/2.0, height/2.0)) // centering force to make sure points don't fly away completely
                //.on("tick", render)
                ;

        while (sim.alpha() > 0.01) { 
          sim.tick(); 
        }

      function render() {
        // data join for edges
        let lines = viewport.selectAll("line.link").data(links)
            .join(
              enter => enter.append("line")
                            .attr("class","link")
                            .attr("stroke","#D3D3D3") 
                            .attr("stroke-width", 3)
                            .style('opacity', 0.6)
            )
            .attr("x1", d => d.source.x).attr("x2", d => d.target.x)   // Using the pointers d3.forceLink provides to access node x and y coords
            .attr("y1", d => d.source.y).attr("y2", d => d.target.y);

        // data join for nodes
        let circles = viewport.selectAll("circle.node").data(nodes)
              .join(
                  enter => enter.append("svg:image")
                                .attr("class","node")
                                .attr("xlink:href", (d) => {
                                  if (d.groups.length > 1) {
                                    return d.name.toLowerCase() + ".svg"
                                  } else if (d.groups.length == 0) {
                                    return "no-subunit-cropped.svg"
                                  } else {
                                    return d.groups[0].replace(/\s+/g, '') + ".svg"
                                  }
                                })
                                .attr("width", 100)
                                .attr("height", 100)
                                .attr("x", -50)
                                .attr("y", -50)
                                // .call( d3.drag().on("start",dragstart)
                                //                  .on("drag",dragging)
                                //                  .on("end",dragend) )
                )
              .attr("transform", d => `translate(${d.x},${d.y})`)
              .attr("name", d => d.name)
        
        // handle mouseover of nodes
        circles.on("mouseover", function(event, d) { 
          let connectedNames = []; // tracking names of nodes connected to the hovered node
          
          // iterating over edges to find the ones that are connected to the hovered node
          d3.selectAll("line.link").each(function(l) {
            if (d === l.source || d === l.target) {
              d3.select(this).classed('hovered-arc', true).raise()
              circles.raise()

              connectedNames.push(l.source.name);
              connectedNames.push(l.target.name);
            } else {
              d3.select(this).classed('hovered-arc', false).lower();
            }
          })
          circles.filter(function() {
                return connectedNames.includes(d3.select(this).attr("name")); 
          }).raise()

          // reduce opacity of unconnected nodes
          circles.filter(function() {
            return !connectedNames.includes(d3.select(this).attr("name")); 
          }).lower().classed('unconnected-node', true)
          d3.select("#small-label").text(d['name']);
        });

        // handle mouseout of nodes
        circles.on("mouseout", function(event, d) {
          d3.selectAll("line.link").classed('hovered-arc', false).lower()
          d3.select("#small-label").text("");
          circles.classed('unconnected-node', false)
        });
      
      }
        render();

        function plotZoomed(event) {  
          viewport.attr("transform", event.transform);
        }
        
        

        }

    requestData()

  </script>



</html>
